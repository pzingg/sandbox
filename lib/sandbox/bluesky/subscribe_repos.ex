defmodule Sandbox.Bluesky.SubscribeRepos do
  @moduledoc """
  Modules for the repos firehose.
  """

  require Logger

  alias Sandbox.Bluesky.CAR
  alias Sandbox.Bluesky.CAR.Op

  defmodule Info do
  end

  defmodule Commit do
    @moduledoc """
    Represents an update of repository state. Note that empty commits are
    allowed, which include no repo data changes, but an update to rev and
    signature.

    ### Commit Objects

    The top-level data object in a repository is a signed commit.
    It is found in the `blocks` element of the `SubscribeRepos.Commit`
    structure.

    The IPLD schema fields are:

    - `repo` (string, required): the account DID associated with the repo, in
      strictly normalized form (eg, lowercase as appropriate)
    - `version` (integer, required): fixed value of `3` for this repo format
      version
    - `blocks` (CID link, required): pointer to the top of the repo contents
      tree structure (MST)
    - `rev` (string, TID format, required): revision of the repo, used as a
      logical clock. Must increase monotonically. Recommend using current
      timestamp as TID; `rev` values in the "future" (beyond a fudge factor)
      should be ignored and not processed.
    - `prev` (CID link, nullable): pointer (by hash) to a previous commit
      object for this repository. Could be used to create a chain of history,
      but largely unused (included for v2 backwards compatibility). In
      version `3` repos, this field must exist in the CBOR object, but is
      virtually always `null`. NOTE: previously specified as nullable and
      optional, but this caused interoperability issues.
    - `sig` (byte array, required): cryptographic signature of this commit,
      as raw bytes

    An UnsignedCommit data object has all the same fields except for `sig`.
    The process for signing a commit is to populate all the data fields,
    and then serialize the UnsignedCommit with DAG-CBOR. The output bytes
    are then hashed with SHA-256, and the binary hash output (without hex
    encoding) is then signed using the current "signing key" for the account.
    The signature is then stored as raw bytes in a commit object, along
    with all the other data fields.

    The CID for a commit overall is generated by serializing a *signed*
    commit object as DAG-CBOR. See notes on the "blessed" CID format below,
    and in particular be sure to use the `dag-cbor` multicodec for CIDs
    linking to commit objects.

    Note that neither the signature itself nor the signed commit indicate
    either the type of key used (curve type), or the specific public key
    used. That information must be fetched from the account's DID document.
    With key rotation, verification of older commit signatures can become
    ambiguous. The most recent commit should always be verifiable using
    the current DID document. This implies that a new repository commit
    should be created every time the signing key is rotated. Such a commit
    does not need to update the `data` CID link.
    """

    @derive Jason.Encoder
    defstruct [
      :seq,
      :rebase,
      :tooBig,
      :repo,
      :commit,
      :prev,
      :rev,
      :since,
      :blocks,
      :ops,
      :blobs,
      :time
    ]

    @type t() :: %__MODULE__{
            seq: integer(),
            rebase: boolean(),
            tooBig: boolean(),
            repo: CAR.didstring(),
            commit: CAR.cidstring(),
            prev: CAR.cidstring(),
            rev: CAR.tidstring(),
            since: CAR.tidstring(),
            blocks: CAR.t() | binary(),
            ops: [Op.t()],
            blobs: list(),
            time: CAR.timestring()
          }

    def new(body) do
      {ops, rest} = Map.pop!(body, :ops)
      ops = Enum.map(ops, &decode_op/1)

      {blocks, rest} = Map.pop!(rest, :blocks)
      blocks = CAR.decode_car!(blocks, !CAR.has_create_post?(ops))

      attrs = Map.merge(rest, %{ops: ops, blocks: blocks})
      commit = struct(__MODULE__, attrs)

      _ = Logger.info("commit: #{inspect(commit)}")

      {:ok, commit}
    end

    def decode_op(op) do
      attrs =
        for {key, value} <- op, into: %{} do
          case {key, value} do
            {:action, value} when is_binary(value) ->
              {key, String.to_atom(value)}

            {:path, _} ->
              {key, CAR.decode_path!(value)}

            _ ->
              {key, value}
          end
        end

      struct(Op, attrs)
    end
  end

  defmodule Handle do
  end

  defmodule Migrate do
  end

  defmodule Tombstone do
  end

  defmodule Identity do
  end

  defmodule Account do
  end
end
